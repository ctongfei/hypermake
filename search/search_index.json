{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"tutorial/01-hello/","text":"Runs a simple \"Hello, world\" task First let's define our first task (without any inputs or outputs declared!): Note the syntax here: A code block starts after the : at the end of the task signature. A code block is a consecutive list of indented lines of scripts, where each line must start with at least 2 spaces. task hello: echo \"Hello, world!\" Save this file as hello.hm . We have created our first Hypermake script file. Now let's run this task! Execute the following command in your shell: The basic command line usage is hypermake <script file> <subtask> <target> . hypermake hello.hm run task We should see the output \"Hello, world!\" printed in the terminal.","title":"01 Hello, world!"},{"location":"tutorial/01-hello/#runs-a-simple-hello-world-task","text":"First let's define our first task (without any inputs or outputs declared!): Note the syntax here: A code block starts after the : at the end of the task signature. A code block is a consecutive list of indented lines of scripts, where each line must start with at least 2 spaces. task hello: echo \"Hello, world!\" Save this file as hello.hm . We have created our first Hypermake script file. Now let's run this task! Execute the following command in your shell: The basic command line usage is hypermake <script file> <subtask> <target> . hypermake hello.hm run task We should see the output \"Hello, world!\" printed in the terminal.","title":"Runs a simple \"Hello, world\" task"},{"location":"tutorial/02-compose/","text":"Inputs, outputs, and composing tasks A task can take parameters, and yield outputs. url = \"https://news.ycombinator.org\" task download ( url = $ ) -> ( out = \"homepage.html\" ) : wget $url -O $out Generally, when declaring a parameter whose default argument is a variable with the same name, one can omit the argument name by just writing $ . Running the task download will download the homepage of the Hacker News. Note the parameter is declared as url=$ : This is a shorthand for url=$url . This task creates a single output called homepage.html : You can find this file at out/download/default directory. One can simply write out instead of (out=\"homepage.html\") : in this case the output file name will be out . Now, we'd like to extract all the headlines: their URLs and titles. We create another task that takes the output of the download task as input: task getTitles ( html = $download .out ) -> out: cat $html \\ | perl -ne 'if (/<a href=\"(.*?)\" class=\"storylink\">(.*?)<\\/a>/) { print \"$1\\t$2\\n\" }' \\ > $out Running the following command hypermake tutorial/ycomb.hm run getTitles will sequentially run the two dependent jobs: first download then getTitles , and the resulting TSV table will be located in out/getTitles/default/out . In the directory out/getTitles/default , you can find the following files that may be of interest: out : the resulting TSV table script.sh : the script that was used to run the task stdout : the standard output of the task stderr : the standard error of the task args : A shell script that contains the arguments that were used to run the task exitcode : A file that contains the exit code of the task To recreate the task in shell, you can use the following command. It should have the same behavior as directly running from Hypermake. . args && . script.sh","title":"02 Inputs & outputs"},{"location":"tutorial/02-compose/#inputs-outputs-and-composing-tasks","text":"A task can take parameters, and yield outputs. url = \"https://news.ycombinator.org\" task download ( url = $ ) -> ( out = \"homepage.html\" ) : wget $url -O $out Generally, when declaring a parameter whose default argument is a variable with the same name, one can omit the argument name by just writing $ . Running the task download will download the homepage of the Hacker News. Note the parameter is declared as url=$ : This is a shorthand for url=$url . This task creates a single output called homepage.html : You can find this file at out/download/default directory. One can simply write out instead of (out=\"homepage.html\") : in this case the output file name will be out . Now, we'd like to extract all the headlines: their URLs and titles. We create another task that takes the output of the download task as input: task getTitles ( html = $download .out ) -> out: cat $html \\ | perl -ne 'if (/<a href=\"(.*?)\" class=\"storylink\">(.*?)<\\/a>/) { print \"$1\\t$2\\n\" }' \\ > $out Running the following command hypermake tutorial/ycomb.hm run getTitles will sequentially run the two dependent jobs: first download then getTitles , and the resulting TSV table will be located in out/getTitles/default/out . In the directory out/getTitles/default , you can find the following files that may be of interest: out : the resulting TSV table script.sh : the script that was used to run the task stdout : the standard output of the task stderr : the standard error of the task args : A shell script that contains the arguments that were used to run the task exitcode : A file that contains the exit code of the task To recreate the task in shell, you can use the following command. It should have the same behavior as directly running from Hypermake. . args && . script.sh","title":"Inputs, outputs, and composing tasks"},{"location":"tutorial/03-branch/","text":"Parameters We'd like to parameterize our tasks: there could be multiple versions of a task. This could be different datasets, different preprocessing pipelines, different pretrained models, etc. Hypermake models these configurations as parameters to values and tasks. For example, we are here downloading various versions of the GloVe embeddings from the Stanford NLP website: gloveUrl = { Version: 6b = \"http://nlp.stanford.edu/data/glove.6B.zip\" cc42b = \"http://nlp.stanford.edu/data/glove.42B.300d.zip\" cc840b = \"http://nlp.stanford.edu/data/glove.840B.300d.zip\" twitter27b = \"http://nlp.stanford.edu/data/glove.twitter.27B.zip\" } task downloadGloVe ( gloveUrl = $ ) -> out: sleep $(( ( $RANDOM % 10 ) + 1 )) s wget -O glove.zip $gloveUrl unzip glove.zip mv *.txt $out rm glove.zip If the key is the same as the value, one can omit the value in the declaration, like this: {Version: 6b cc42b cc840b twitter27b} . Note that we declared a Dict -like object here: {Version: 6b=XX cc42b=XX cc840b=XX twitter27b=XX} . This is a parameter declaration: the name of the parameter is Version , and it has 4 potential keys 6b , cc42b , cc840b , and twitter27b . Each key is associated with a value that follows the key (that is the URL in this example). Our task downloadGloVe is now parameterized with variable Version . To refer to one of these task (a case ), we can use the indexing notation task[Var:key] : here for example downloadGloVe[Version:6b] . We can use the task referring expressions in the Hypermake command line interface. To download GloVe 6b version, do hypermake glove.hm run downloadGloVe [ Version:6b ] One can use [Var:*] syntax to refer to all cases of the task. The following command line invocation downloads all GloVe versions: hypermake glove.hm run 'downloadGloVe[Version: *]' Single-quoting the task downloadGlove[Version: *] prohibits bash from expanding the wildcard * symbol. Again, we can find the output files in out/downloadGloVe/Version=XX .","title":"03 Parameters"},{"location":"tutorial/03-branch/#parameters","text":"We'd like to parameterize our tasks: there could be multiple versions of a task. This could be different datasets, different preprocessing pipelines, different pretrained models, etc. Hypermake models these configurations as parameters to values and tasks. For example, we are here downloading various versions of the GloVe embeddings from the Stanford NLP website: gloveUrl = { Version: 6b = \"http://nlp.stanford.edu/data/glove.6B.zip\" cc42b = \"http://nlp.stanford.edu/data/glove.42B.300d.zip\" cc840b = \"http://nlp.stanford.edu/data/glove.840B.300d.zip\" twitter27b = \"http://nlp.stanford.edu/data/glove.twitter.27B.zip\" } task downloadGloVe ( gloveUrl = $ ) -> out: sleep $(( ( $RANDOM % 10 ) + 1 )) s wget -O glove.zip $gloveUrl unzip glove.zip mv *.txt $out rm glove.zip If the key is the same as the value, one can omit the value in the declaration, like this: {Version: 6b cc42b cc840b twitter27b} . Note that we declared a Dict -like object here: {Version: 6b=XX cc42b=XX cc840b=XX twitter27b=XX} . This is a parameter declaration: the name of the parameter is Version , and it has 4 potential keys 6b , cc42b , cc840b , and twitter27b . Each key is associated with a value that follows the key (that is the URL in this example). Our task downloadGloVe is now parameterized with variable Version . To refer to one of these task (a case ), we can use the indexing notation task[Var:key] : here for example downloadGloVe[Version:6b] . We can use the task referring expressions in the Hypermake command line interface. To download GloVe 6b version, do hypermake glove.hm run downloadGloVe [ Version:6b ] One can use [Var:*] syntax to refer to all cases of the task. The following command line invocation downloads all GloVe versions: hypermake glove.hm run 'downloadGloVe[Version: *]' Single-quoting the task downloadGlove[Version: *] prohibits bash from expanding the wildcard * symbol. Again, we can find the output files in out/downloadGloVe/Version=XX .","title":"Parameters"},{"location":"tutorial/04-parameterized-compose/","text":"Composing parameterized tasks","title":"04 Parameterized pipelines"},{"location":"tutorial/04-parameterized-compose/#composing-parameterized-tasks","text":"","title":"Composing parameterized tasks"},{"location":"tutorial/05-functions/","text":"","title":"05 Functions"},{"location":"tutorial/06-decorators/","text":"Decorators In Hypermake, a task can be decorated with some decorators, effectively modifying its behavior. This can support - Running with different shell; - Running in specific virtual environments; - Running through some cluster submission systems; - etc. The general syntax for defining a decorator is: def <decoratorName> ( <arguments> ) <- input = <internalScriptName>: <script> and when applying a decorator, one could write @<decoratorName> ( <arguments> ) task taskName ( ... ) -> out: ... This will modify the task with the decorator. The script to be modified will be stored as internalScriptName . Example 1: A simple decorator An example that let us runs a task in Python instead of shell: def python () <- internalPythonScript = \"script.py\" : python $internalPythonScript @python task helloWorldInPython: print ( \"Hello World\" + \" \" + \"in Python!\" ) And we can invoke the task from the command line: hypermake tutorial/decorators.hm run helloWorldInPython Let's see what's happening under the hood here. The script in the task helloWorldInPython is decorated with @python . The script with the line print(...) is stored as script.py as directed in the decorator. Then, in shell, the command in the decorator is run instead: python script.py . Example 2: A parameterized decorator In Python, a task can be run in different Conda virtual environments. This is a decorator that lets us do that. def conda ( env ) <- internalCondaScript = \"conda-internal.sh\" : eval \" $( command conda 'shell.bash' 'hook' 2 > /dev/null ) \" conda activate $env . $internalCondaScript conda deactivate @conda ( env ={ Env: base myenv }) task helloWorldFromEnv: python -c \"print('Hello World in Python from $env !')\" Note that in the task helloWorldFromEnv , the decorator conda has a parameterized argument: env={Env: base myenv} . We can invoke both cases of the task helloWorldFromEnv : hypermake tutorial/decorators.hm run 'helloWorldFromEnv[Env: *]' We will see both lines Hello World in Python from base! Hello World in Python from myenv! output to the terminal. Example 3: Chaining decorators We have now created two decorators: @python that executes a script using Python instead of Bash as the interpreter; @conda that runs a task in a specific Conda virtual environment. Can we compose these decorators? Yes. @conda ( env = { Env : base myenv }) @python task helloWorldInPythonFromEnv : import os print ( f \"Hello World in Python from { os . environ [ 'env' ] } !\" ) One can use os.environ[var] to get the environment variable $var in Python. First, our script is wrapped by @python , then @conda(env) . Recall that Hypermake passes parameters into the script as environment variables: we cannot use $env to get the Hypermake variable in Python.","title":"06 Decorators"},{"location":"tutorial/06-decorators/#decorators","text":"In Hypermake, a task can be decorated with some decorators, effectively modifying its behavior. This can support - Running with different shell; - Running in specific virtual environments; - Running through some cluster submission systems; - etc. The general syntax for defining a decorator is: def <decoratorName> ( <arguments> ) <- input = <internalScriptName>: <script> and when applying a decorator, one could write @<decoratorName> ( <arguments> ) task taskName ( ... ) -> out: ... This will modify the task with the decorator. The script to be modified will be stored as internalScriptName .","title":"Decorators"},{"location":"tutorial/06-decorators/#example-1-a-simple-decorator","text":"An example that let us runs a task in Python instead of shell: def python () <- internalPythonScript = \"script.py\" : python $internalPythonScript @python task helloWorldInPython: print ( \"Hello World\" + \" \" + \"in Python!\" ) And we can invoke the task from the command line: hypermake tutorial/decorators.hm run helloWorldInPython Let's see what's happening under the hood here. The script in the task helloWorldInPython is decorated with @python . The script with the line print(...) is stored as script.py as directed in the decorator. Then, in shell, the command in the decorator is run instead: python script.py .","title":"Example 1: A simple decorator"},{"location":"tutorial/06-decorators/#example-2-a-parameterized-decorator","text":"In Python, a task can be run in different Conda virtual environments. This is a decorator that lets us do that. def conda ( env ) <- internalCondaScript = \"conda-internal.sh\" : eval \" $( command conda 'shell.bash' 'hook' 2 > /dev/null ) \" conda activate $env . $internalCondaScript conda deactivate @conda ( env ={ Env: base myenv }) task helloWorldFromEnv: python -c \"print('Hello World in Python from $env !')\" Note that in the task helloWorldFromEnv , the decorator conda has a parameterized argument: env={Env: base myenv} . We can invoke both cases of the task helloWorldFromEnv : hypermake tutorial/decorators.hm run 'helloWorldFromEnv[Env: *]' We will see both lines Hello World in Python from base! Hello World in Python from myenv! output to the terminal.","title":"Example 2: A parameterized decorator"},{"location":"tutorial/06-decorators/#example-3-chaining-decorators","text":"We have now created two decorators: @python that executes a script using Python instead of Bash as the interpreter; @conda that runs a task in a specific Conda virtual environment. Can we compose these decorators? Yes. @conda ( env = { Env : base myenv }) @python task helloWorldInPythonFromEnv : import os print ( f \"Hello World in Python from { os . environ [ 'env' ] } !\" ) One can use os.environ[var] to get the environment variable $var in Python. First, our script is wrapped by @python , then @conda(env) . Recall that Hypermake passes parameters into the script as environment variables: we cannot use $env to get the Hypermake variable in Python.","title":"Example 3: Chaining decorators"},{"location":"tutorial/07-environments/","text":"","title":"07 environments"}]}