{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"tutorial/01-hello/","text":"Runs a simple \"Hello, world\" task First let's define our first task (without any inputs or outputs declared!): Note the syntax here: A code block starts after the : at the end of the task signature. A code block is a consecutive list of indented lines of scripts, where each line must start with at least 2 spaces. task hello: echo \"Hello, world!\" Save this file as hello.hm . We have created our first Hypermake script file. Now let's run this task! Execute the following command in your shell: The basic command line usage is hypermake <script file> <subtask> <target> . hypermake hello.hm run task We should see the output \"Hello, world!\" printed in the terminal.","title":"01 Hello, world!"},{"location":"tutorial/01-hello/#runs-a-simple-hello-world-task","text":"First let's define our first task (without any inputs or outputs declared!): Note the syntax here: A code block starts after the : at the end of the task signature. A code block is a consecutive list of indented lines of scripts, where each line must start with at least 2 spaces. task hello: echo \"Hello, world!\" Save this file as hello.hm . We have created our first Hypermake script file. Now let's run this task! Execute the following command in your shell: The basic command line usage is hypermake <script file> <subtask> <target> . hypermake hello.hm run task We should see the output \"Hello, world!\" printed in the terminal.","title":"Runs a simple \"Hello, world\" task"},{"location":"tutorial/02-compose/","text":"Inputs, outputs, and composing tasks A task can take parameters, and yield outputs. url = \"https://news.ycombinator.org\" task download ( url = $ ) -> ( out = \"homepage.html\" ) : wget $url -O $out Generally, when declaring a parameter whose default argument is a variable with the same name, one can omit the argument name by just writing $ . Running the task download will download the homepage of the Hacker News. Note the parameter is declared as url=$ : This is a shorthand for url=$url . This task creates a single output called homepage.html : You can find this file at out/download/default directory. One can simply write out instead of (out=\"homepage.html\") : in this case the output file name will be out . Now, we'd like to extract all the headlines: their URLs and titles. We create another task that takes the output of the download task as input: task getTitles ( html = $download .out ) -> out: cat $html \\ | perl -ne 'if (/<a href=\"(.*?)\" class=\"storylink\">(.*?)<\\/a>/) { print \"$1\\t$2\\n\" }' \\ > $out Running the following command hypermake tutorial/02.hm run getTitles will sequentially run the two dependent jobs: first download then getTitles , and the resulting TSV table will be located in out/getTitles/default/out .","title":"02 Inputs & outputs"},{"location":"tutorial/02-compose/#inputs-outputs-and-composing-tasks","text":"A task can take parameters, and yield outputs. url = \"https://news.ycombinator.org\" task download ( url = $ ) -> ( out = \"homepage.html\" ) : wget $url -O $out Generally, when declaring a parameter whose default argument is a variable with the same name, one can omit the argument name by just writing $ . Running the task download will download the homepage of the Hacker News. Note the parameter is declared as url=$ : This is a shorthand for url=$url . This task creates a single output called homepage.html : You can find this file at out/download/default directory. One can simply write out instead of (out=\"homepage.html\") : in this case the output file name will be out . Now, we'd like to extract all the headlines: their URLs and titles. We create another task that takes the output of the download task as input: task getTitles ( html = $download .out ) -> out: cat $html \\ | perl -ne 'if (/<a href=\"(.*?)\" class=\"storylink\">(.*?)<\\/a>/) { print \"$1\\t$2\\n\" }' \\ > $out Running the following command hypermake tutorial/02.hm run getTitles will sequentially run the two dependent jobs: first download then getTitles , and the resulting TSV table will be located in out/getTitles/default/out .","title":"Inputs, outputs, and composing tasks"},{"location":"tutorial/03-branch/","text":"Hyperparameters We'd like to parameterize our tasks: there could be multiple versions of a task. This could be different datasets, different preprocessing pipelines, different pretrained models, etc. Hypermake models these configurations as parameters to values and tasks. For example, we are here downloading various versions of the GloVe embeddings from the Stanford NLP website: gloveUrl = { Version: 6b = \"http://nlp.stanford.edu/data/glove.6B.zip\" , cc42b = \"http://nlp.stanford.edu/data/glove.42B.300d.zip\" , cc840b = \"http://nlp.stanford.edu/data/glove.840B.300d.zip\" , twitter27b = \"http://nlp.stanford.edu/data/glove.twitter.27B.zip\" } task downloadGloVe ( gloveUrl = $ ) -> out: wget -O glove.zip $gloveUrl unzip glove.zip mv *.txt $out rm glove.zip If the key is the same as the value, one can omit the value in the declaration, like this: {Version: 6b cc42b cc840b twitter27b} . Note that we declared a Dict -like object here: {Version: 6b=XX cc42b=XX cc840b=XX twitter27b=XX} . This is a parameter declaration: the name of the parameter is Version , and it has 4 potential keys 6b , cc42b , cc840b , and twitter27b . Each key is associated with a value that follows the key (that is the URL in this example). Our task downloadGloVe is now parameterized with variable Version . To refer to one of these task (a case ), we can use the indexing notation task[Var:key] : here for example downloadGloVe[Version:6b] . We can use the task referring expressions in the Hypermake command line interface. To download GloVe 6b version, do hypermake glove.hm run downloadGloVe [ Version:6b ] One can use [Var:*] syntax to refer to all cases of the task. The following command line invocation downloads all GloVe versions: hypermake glove.hm run downloadGloVe [ Version: * ]","title":"03 Parameters"},{"location":"tutorial/03-branch/#hyperparameters","text":"We'd like to parameterize our tasks: there could be multiple versions of a task. This could be different datasets, different preprocessing pipelines, different pretrained models, etc. Hypermake models these configurations as parameters to values and tasks. For example, we are here downloading various versions of the GloVe embeddings from the Stanford NLP website: gloveUrl = { Version: 6b = \"http://nlp.stanford.edu/data/glove.6B.zip\" , cc42b = \"http://nlp.stanford.edu/data/glove.42B.300d.zip\" , cc840b = \"http://nlp.stanford.edu/data/glove.840B.300d.zip\" , twitter27b = \"http://nlp.stanford.edu/data/glove.twitter.27B.zip\" } task downloadGloVe ( gloveUrl = $ ) -> out: wget -O glove.zip $gloveUrl unzip glove.zip mv *.txt $out rm glove.zip If the key is the same as the value, one can omit the value in the declaration, like this: {Version: 6b cc42b cc840b twitter27b} . Note that we declared a Dict -like object here: {Version: 6b=XX cc42b=XX cc840b=XX twitter27b=XX} . This is a parameter declaration: the name of the parameter is Version , and it has 4 potential keys 6b , cc42b , cc840b , and twitter27b . Each key is associated with a value that follows the key (that is the URL in this example). Our task downloadGloVe is now parameterized with variable Version . To refer to one of these task (a case ), we can use the indexing notation task[Var:key] : here for example downloadGloVe[Version:6b] . We can use the task referring expressions in the Hypermake command line interface. To download GloVe 6b version, do hypermake glove.hm run downloadGloVe [ Version:6b ] One can use [Var:*] syntax to refer to all cases of the task. The following command line invocation downloads all GloVe versions: hypermake glove.hm run downloadGloVe [ Version: * ]","title":"Hyperparameters"}]}